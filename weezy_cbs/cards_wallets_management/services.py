# Service layer for Cards & Wallets Management
from sqlalchemy.orm import Session
from sqlalchemy import func
from . import models, schemas
from .models import CardStatusEnum, WalletAccountStatusEnum, WalletTransactionTypeEnum, CurrencyEnum # Enums
import decimal
import random
import string
from datetime import datetime, timedelta
import hashlib # For hashing PAN if stored (ensure compliance)

# Placeholder for other service integrations
# from weezy_cbs.customer_identity_management.services import get_customer
# from weezy_cbs.accounts_ledger_management.services import get_account_by_id as get_bank_account, post_double_entry_transaction
# from weezy_cbs.accounts_ledger_management.schemas import PostTransactionRequest as LedgerPostRequest
# from weezy_cbs.integrations import card_processor_service # e.g., Interswitch, UPSL, Payment Gateway
# from weezy_cbs.shared import exceptions, security_utils # For encryption/hashing

class NotFoundException(Exception): pass
class InvalidOperationException(Exception): pass
class InsufficientFundsException(InvalidOperationException): pass
class ExternalServiceException(Exception): pass

# --- Card Services ---
def _generate_masked_pan(pan: str) -> str:
    if len(pan) < 10: return pan # Not a valid PAN to mask typically
    return f"{pan[:6]}******{pan[-4:]}"

def _hash_pan(pan: str) -> str:
    # Use a strong, salted hash (e.g., SHA256). For PCI, specific requirements apply.
    # This is a simplified example.
    return hashlib.sha256(pan.encode()).hexdigest()

def request_new_card(db: Session, card_request: schemas.CardCreateRequest, customer_id: int, account_id: int) -> models.Card:
    # customer = get_customer(db, customer_id)
    # if not customer: raise NotFoundException("Customer not found.")
    # bank_account = get_bank_account(db, account_id)
    # if not bank_account or bank_account.customer_id != customer_id:
    #     raise InvalidOperationException("Invalid bank account or account does not belong to customer.")

    # In a real system, PAN, Expiry, CVV would be generated by the card processor/scheme.
    # For mock purposes:
    mock_pan = "".join(random.choices(string.digits, k=16))
    mock_expiry_month = random.randint(1, 12)
    mock_expiry_year = datetime.utcnow().year + random.randint(3, 5)
    mock_expiry_date = f"{mock_expiry_month:02d}/{str(mock_expiry_year)[-2:]}"
    # mock_cvv = "".join(random.choices(string.digits, k=3)) # CVV not typically stored long-term

    db_card = models.Card(
        customer_id=customer_id,
        account_id=account_id,
        card_number_masked=_generate_masked_pan(mock_pan),
        card_number_hashed=_hash_pan(mock_pan), # Store hash for lookups if needed
        # card_processor_token = card_processor_service.tokenize_card(mock_pan, mock_expiry_date, mock_cvv) # Ideal
        card_type=card_request.card_type,
        card_scheme=card_request.card_scheme,
        expiry_date=mock_expiry_date,
        # cvv_encrypted=security_utils.encrypt(mock_cvv), # If temporarily stored for issuance
        cardholder_name=card_request.cardholder_name,
        status=CardStatusEnum.REQUESTED # Or INACTIVE if issued immediately by processor
    )
    db.add(db_card)
    db.commit()
    db.refresh(db_card)

    # If physical, trigger dispatch process. If virtual, might be immediately available.
    # card_processor_service.issue_card(db_card.id, card_details_for_processor)
    return db_card

def get_card_by_id(db: Session, card_id: int) -> Optional[models.Card]:
    return db.query(models.Card).filter(models.Card.id == card_id).first()

def get_cards_for_customer(db: Session, customer_id: int, skip: int = 0, limit: int = 10) -> List[models.Card]:
    return db.query(models.Card).filter(models.Card.customer_id == customer_id).offset(skip).limit(limit).all()

def activate_card(db: Session, card_id: int, activation_details: schemas.CardActivationRequest) -> models.Card:
    card = get_card_by_id(db, card_id)
    if not card: raise NotFoundException("Card not found.")
    if card.status != CardStatusEnum.INACTIVE and card.status != CardStatusEnum.REQUESTED: # Some cards might be directly issuable as INACTIVE
        raise InvalidOperationException(f"Card cannot be activated. Current status: {card.status.value}")

    # Add verification logic here (e.g., match last4digits, DOB, activation_code OTP)
    # if activation_details.last4digits_pan and not card.card_number_masked.endswith(activation_details.last4digits_pan):
    #     raise InvalidOperationException("Card PAN mismatch for activation.")

    card.status = CardStatusEnum.ACTIVE
    card.activated_at = datetime.utcnow()
    card.pin_change_required = True # Force PIN set after activation
    db.commit()
    db.refresh(card)
    # card_processor_service.update_card_status(card.card_processor_token, "ACTIVE")
    return card

def set_card_pin(db: Session, card_id: int, pin_request: schemas.CardPinSetRequest) -> models.Card:
    card = get_card_by_id(db, card_id)
    if not card: raise NotFoundException("Card not found.")
    if card.status != CardStatusEnum.ACTIVE: # Must be active to set PIN
        raise InvalidOperationException("Card is not active. Cannot set PIN.")

    # Secure PIN handling: Send PIN block to HSM/Card Processor
    # success = card_processor_service.set_pin(card.card_processor_token, pin_request.new_pin)
    # if not success:
    #     raise ExternalServiceException("Failed to set PIN with card processor.")

    card.is_pin_set = True
    card.pin_change_required = False
    card.failed_pin_attempts = 0 # Reset failed attempts
    db.commit()
    db.refresh(card)
    return card

def update_card_status(db: Session, card_id: int, status_request: schemas.CardStatusUpdateRequest) -> models.Card:
    card = get_card_by_id(db, card_id)
    if not card: raise NotFoundException("Card not found.")

    # Validate status transition (e.g., cannot unblock a PERM_BLOCKED card easily)
    if card.status == CardStatusEnum.BLOCKED_PERM and status_request.new_status != CardStatusEnum.BLOCKED_PERM:
        raise InvalidOperationException("Permanently blocked card status cannot be changed by user.")

    card.status = status_request.new_status
    # card_processor_service.update_card_status(card.card_processor_token, status_request.new_status.value)
    db.commit()
    db.refresh(card)
    return card

# --- Wallet Account Services ---
def create_wallet_account(db: Session, wallet_create_req: schemas.WalletAccountCreateRequest, customer_id: int) -> models.WalletAccount:
    # customer = get_customer(db, customer_id)
    # if not customer: raise NotFoundException("Customer not found for wallet creation.")

    # Check if customer already has a wallet for this currency (if policy is one wallet per currency)
    existing_wallet = db.query(models.WalletAccount).filter(
        models.WalletAccount.customer_id == customer_id,
        models.WalletAccount.currency == wallet_create_req.currency
    ).first()
    if existing_wallet:
        raise InvalidOperationException(f"Customer already has a {wallet_create_req.currency.value} wallet.")

    external_wallet_id = "WLT" + "".join(random.choices(string.ascii_uppercase + string.digits, k=12))
    db_wallet = models.WalletAccount(
        customer_id=customer_id,
        wallet_id_external=external_wallet_id,
        currency=wallet_create_req.currency,
        status=WalletAccountStatusEnum.ACTIVE,
        balance=decimal.Decimal("0.0") # Initial balance
    )
    db.add(db_wallet)
    db.commit()
    db.refresh(db_wallet)

    # Handle initial top-up if provided in wallet_create_req
    # if wallet_create_req.initial_top_up_amount and wallet_create_req.initial_top_up_amount > 0:
    #     top_up_req = schemas.WalletTopUpRequest(
    #         amount=wallet_create_req.initial_top_up_amount,
    #         currency=wallet_create_req.currency,
    #         funding_source_type="INITIAL_SETUP", # Or actual source if provided
    #         funding_source_reference=wallet_create_req.funding_source_ref or "SYSTEM_INIT"
    #     )
    #     top_up_wallet_account(db, db_wallet.id, top_up_req) # Internal wallet ID
    return db_wallet

def get_wallet_account_by_id(db: Session, wallet_db_id: int) -> Optional[models.WalletAccount]:
    return db.query(models.WalletAccount).filter(models.WalletAccount.id == wallet_db_id).first()

def get_wallet_account_by_external_id(db: Session, external_wallet_id: str) -> Optional[models.WalletAccount]:
    return db.query(models.WalletAccount).filter(models.WalletAccount.wallet_id_external == external_wallet_id).first()

def get_wallet_accounts_for_customer(db: Session, customer_id: int) -> List[models.WalletAccount]:
    return db.query(models.WalletAccount).filter(models.WalletAccount.customer_id == customer_id).all()

def _create_wallet_transaction_entry(
    db: Session, wallet_id: int, type: WalletTransactionTypeEnum, amount: decimal.Decimal,
    currency: CurrencyEnum, narration: Optional[str], reference: str,
    balance_before: decimal.Decimal, balance_after: decimal.Decimal,
    status: str = "SUCCESSFUL", financial_transaction_id: Optional[str] = None
) -> models.WalletTransaction:

    entry = models.WalletTransaction(
        wallet_account_id=wallet_id,
        # financial_transaction_id=financial_transaction_id, # If linked to master FT
        transaction_type=type,
        amount=amount,
        currency=currency,
        narration=narration,
        reference=reference,
        status=status,
        balance_before=balance_before,
        balance_after=balance_after,
        transaction_date=datetime.utcnow()
    )
    db.add(entry)
    return entry

def top_up_wallet_account(db: Session, wallet_db_id: int, top_up_request: schemas.WalletTopUpRequest) -> models.WalletAccount:
    wallet = db.query(models.WalletAccount).filter(models.WalletAccount.id == wallet_db_id).with_for_update().first()
    if not wallet: raise NotFoundException("Wallet account not found.")
    if wallet.status != WalletAccountStatusEnum.ACTIVE:
        raise InvalidOperationException("Wallet is not active.")
    if wallet.currency != top_up_request.currency: # Or handle currency conversion
        raise InvalidOperationException("Top-up currency mismatch with wallet currency.")

    # Process funding source (e.g., charge card, debit bank account via payment gateway or ledger)
    # This is a complex step involving integration with other modules/services.
    # payment_success = payment_gateway_service.charge(
    #     top_up_request.funding_source_type,
    #     top_up_request.funding_source_reference,
    #     top_up_request.amount
    # )
    # if not payment_success:
    #     raise ExternalServiceException("Failed to process funding source for wallet top-up.")

    # If funding successful:
    balance_before = wallet.balance
    wallet.balance += top_up_request.amount
    balance_after = wallet.balance

    _create_wallet_transaction_entry(
        db, wallet_id=wallet.id, type=WalletTransactionTypeEnum.TOP_UP,
        amount=top_up_request.amount, currency=wallet.currency,
        narration=f"Top-up from {top_up_request.funding_source_type}",
        reference="WTU_" + uuid.uuid4().hex[:10].upper(), # Generate unique ref
        balance_before=balance_before, balance_after=balance_after
    )

    db.commit()
    db.refresh(wallet)
    return wallet

def withdraw_from_wallet_account(db: Session, wallet_db_id: int, withdrawal_request: schemas.WalletWithdrawalRequest) -> models.WalletAccount:
    wallet = db.query(models.WalletAccount).filter(models.WalletAccount.id == wallet_db_id).with_for_update().first()
    if not wallet: raise NotFoundException("Wallet account not found.")
    if wallet.status != WalletAccountStatusEnum.ACTIVE:
        raise InvalidOperationException("Wallet is not active.")
    if wallet.currency != withdrawal_request.currency:
        raise InvalidOperationException("Withdrawal currency mismatch.")
    if wallet.balance < withdrawal_request.amount:
        raise InsufficientFundsException("Insufficient wallet balance for withdrawal.")

    # Process withdrawal to destination (e.g., credit bank account via NIP or internal transfer)
    # success = payout_service.payout(
    #     withdrawal_request.destination_type,
    #     withdrawal_request.destination_reference,
    #     withdrawal_request.amount
    # )
    # if not success:
    #     raise ExternalServiceException("Failed to process withdrawal to destination.")

    balance_before = wallet.balance
    wallet.balance -= withdrawal_request.amount
    balance_after = wallet.balance

    _create_wallet_transaction_entry(
        db, wallet_id=wallet.id, type=WalletTransactionTypeEnum.WITHDRAWAL,
        amount=withdrawal_request.amount, currency=wallet.currency,
        narration=f"Withdrawal to {withdrawal_request.destination_type}: {withdrawal_request.destination_reference}",
        reference="WWD_" + uuid.uuid4().hex[:10].upper(),
        balance_before=balance_before, balance_after=balance_after
    )
    db.commit()
    db.refresh(wallet)
    return wallet

def p2p_wallet_transfer(db: Session, p2p_request: schemas.WalletP2PTransferRequest, source_wallet_db_id: int) -> tuple[models.WalletAccount, models.WalletAccount]:
    source_wallet = db.query(models.WalletAccount).filter(models.WalletAccount.id == source_wallet_db_id).with_for_update().first()
    destination_wallet = db.query(models.WalletAccount).filter(models.WalletAccount.wallet_id_external == p2p_request.destination_wallet_id_external).with_for_update().first()

    if not source_wallet: raise NotFoundException("Source wallet not found.")
    if not destination_wallet: raise NotFoundException("Destination wallet not found.")

    if source_wallet.status != WalletAccountStatusEnum.ACTIVE or destination_wallet.status != WalletAccountStatusEnum.ACTIVE:
        raise InvalidOperationException("One or both wallets are not active.")
    if source_wallet.currency != p2p_request.currency or destination_wallet.currency != p2p_request.currency: # Basic check, could allow cross-currency with FX
        raise InvalidOperationException("Currency mismatch for P2P transfer.")
    if source_wallet.balance < p2p_request.amount:
        raise InsufficientFundsException("Insufficient balance in source wallet.")
    if source_wallet.id == destination_wallet.id:
        raise InvalidOperationException("Cannot transfer to the same wallet.")

    # Debit source wallet
    source_bal_before = source_wallet.balance
    source_wallet.balance -= p2p_request.amount
    _create_wallet_transaction_entry(
        db, wallet_id=source_wallet.id, type=WalletTransactionTypeEnum.P2P_SEND,
        amount=p2p_request.amount, currency=source_wallet.currency,
        narration=f"Sent to {destination_wallet.wallet_id_external}: {p2p_request.narration or ''}",
        reference="WP2PS_" + uuid.uuid4().hex[:9].upper(),
        balance_before=source_bal_before, balance_after=source_wallet.balance
    )

    # Credit destination wallet
    dest_bal_before = destination_wallet.balance
    destination_wallet.balance += p2p_request.amount
    _create_wallet_transaction_entry(
        db, wallet_id=destination_wallet.id, type=WalletTransactionTypeEnum.P2P_RECEIVE,
        amount=p2p_request.amount, currency=destination_wallet.currency,
        narration=f"Received from {source_wallet.wallet_id_external}: {p2p_request.narration or ''}",
        reference="WP2PR_" + uuid.uuid4().hex[:9].upper(),
        balance_before=dest_bal_before, balance_after=destination_wallet.balance
    )

    db.commit()
    db.refresh(source_wallet)
    db.refresh(destination_wallet)
    return source_wallet, destination_wallet

# --- Cardless Withdrawal Services ---
def generate_cardless_withdrawal_token(db: Session, request: schemas.CardlessWithdrawalRequest, account_id: int) -> models.CardlessWithdrawalToken:
    # bank_account = get_bank_account(db, account_id)
    # if not bank_account: raise NotFoundException("Bank account not found.")
    # if bank_account.available_balance < request.amount: # Check available balance from ledger
    #     raise InsufficientFundsException("Insufficient account balance for cardless withdrawal.")

    # Place a lien on the bank_account for request.amount here
    # lien_success = accounts_ledger_service.place_lien(db, bank_account.account_number, request.amount, "CARDLESS_WITHDRAWAL_TOKEN")
    # if not lien_success:
    #     raise InvalidOperationException("Failed to place lien on account for cardless withdrawal.")

    token_str = "".join(random.choices(string.digits, k=12)) # Example token
    expiry = datetime.utcnow() + timedelta(hours=24) # Token valid for 24 hours

    db_token = models.CardlessWithdrawalToken(
        account_id=account_id,
        token=token_str,
        amount=request.amount,
        currency=request.currency,
        status="ACTIVE",
        expiry_date=expiry
    )
    db.add(db_token)
    db.commit()
    db.refresh(db_token)

    # Send token (and potentially a separate OTP) to user via SMS/Email
    # notification_service.send_sms(user.phone, f"Your cardless withdrawal token is {token_str}. Amount: {request.amount} {request.currency}. Expires {expiry}.")
    return db_token

def redeem_cardless_withdrawal_token(db: Session, redemption_req: schemas.CardlessWithdrawalRedemptionRequest) -> str:
    token_record = db.query(models.CardlessWithdrawalToken).filter(
        models.CardlessWithdrawalToken.token == redemption_req.token,
        models.CardlessWithdrawalToken.status == "ACTIVE"
    ).with_for_update().first()

    if not token_record: return "FAILED_INVALID_TOKEN"
    if token_record.expiry_date < datetime.utcnow():
        token_record.status = "EXPIRED"
        db.commit()
        return "FAILED_EXPIRED_TOKEN"

    # Validate OTP (e.g., redemption_req.one_time_pin against a stored hash or service)
    # is_otp_valid = security_utils.verify_otp(token_record.account_id, redemption_req.one_time_pin)
    # if not is_otp_valid:
    #     # Increment failed attempts, potentially lock token
    #     return "FAILED_INVALID_PIN"

    # If all checks pass, proceed with dispensing cash (this is conceptual for ATM)
    # and debiting the linked account / releasing the lien and posting debit.

    # debit_success = accounts_ledger_service.debit_for_cardless_withdrawal(
    #     db, token_record.account_id, token_record.amount, token_record.token, redemption_req.terminal_id
    # )
    # if not debit_success:
    #     # Release lien if debit fails after lien was placed
    #     return "FAILED_ACCOUNT_DEBIT"

    token_record.status = "USED"
    token_record.used_at = datetime.utcnow()
    token_record.atm_id_used = redemption_req.terminal_id
    db.commit()
    return "SUCCESSFUL"


# --- Transaction History (Card & Wallet) ---
def get_wallet_transactions(db: Session, wallet_db_id: int, skip: int = 0, limit: int = 20) -> List[models.WalletTransaction]:
    return db.query(models.WalletTransaction).filter(models.WalletTransaction.wallet_account_id == wallet_db_id).order_by(models.WalletTransaction.transaction_date.desc()).offset(skip).limit(limit).all()

def get_card_transactions_log(db: Session, card_id: int, skip: int = 0, limit: int = 20) -> List[models.CardTransaction]:
    # This would typically query a denormalized transaction log, or join with FinancialTransaction
    # For now, assuming a CardTransaction model exists and is populated by processor webhooks/ETL
    return db.query(models.CardTransaction).filter(models.CardTransaction.card_id == card_id).order_by(models.CardTransaction.transaction_date.desc()).offset(skip).limit(limit).all()

# Note: Actual card transaction processing (POS, ATM, Web) involves:
# 1. Receiving authorization requests from Switch/Processor.
# 2. Validating card status, PIN (if applicable), limits, account balance.
# 3. Responding with approval/denial.
# 4. Receiving settlement files and posting to ledger.
# This service layer primarily manages the state of cards/wallets and initiates high-level operations.
# Deep integration with a card processor (e.g. Interswitch, UPSL, Mastercard/Visa APIs) is essential.
