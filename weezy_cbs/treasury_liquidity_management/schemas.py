# Pydantic schemas for Treasury & Liquidity Management Module
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from datetime import datetime, date
import decimal

from .models import CurrencyEnum, FXTransactionTypeEnum # Import enums

# --- Bank Cash Position Schemas ---
class BankCashPositionBase(BaseModel):
    position_date: date
    currency: CurrencyEnum
    total_cash_at_vault: decimal.Decimal = Field(..., ge=0, decimal_places=2)
    total_cash_at_cbn: decimal.Decimal = Field(..., ge=0, decimal_places=2)
    total_cash_at_correspondent_banks: decimal.Decimal = Field(..., ge=0, decimal_places=2)
    # liquidity_ratio: Optional[decimal.Decimal] = Field(None, ge=0, decimal_places=4)

class BankCashPositionCreate(BankCashPositionBase):
    # Usually created by a batch process summarizing ledger balances
    pass

class BankCashPositionResponse(BankCashPositionBase):
    id: int
    calculated_at: datetime

    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = { decimal.Decimal: str }

# --- FX Transaction Schemas ---
class FXTransactionBase(BaseModel):
    transaction_type: FXTransactionTypeEnum
    trade_date: date
    value_date: date
    currency_pair: str = Field(..., pattern=r"^[A-Z]{3}/[A-Z]{3}$") # e.g. USD/NGN
    rate: decimal.Decimal = Field(..., gt=0, decimal_places=8)
    buy_currency: CurrencyEnum
    buy_amount: decimal.Decimal = Field(..., gt=0, decimal_places=2)
    sell_currency: CurrencyEnum
    sell_amount: decimal.Decimal = Field(..., gt=0, decimal_places=2) # Should be validated against buy_amount * rate
    counterparty_name: str
    status: Optional[str] = "PENDING_SETTLEMENT" # Default for new deals
    # created_by_user_id: str # Usually from auth context

    @validator('sell_currency')
    def check_currency_pair_consistency_sell(cls, v, values):
        if 'currency_pair' in values and 'buy_currency' in values:
            pair_parts = values['currency_pair'].split('/')
            if not ( (values['buy_currency'].value == pair_parts[0] and v.value == pair_parts[1]) or \
                     (values['buy_currency'].value == pair_parts[1] and v.value == pair_parts[0]) ):
                raise ValueError("Buy/Sell currencies must match the currency pair.")
        return v

    # Add validation for sell_amount based on buy_amount and rate if needed,
    # though it might be complex due to which one is primary input.

class FXTransactionCreateRequest(FXTransactionBase):
    deal_reference: Optional[str] = None # Can be auto-generated by system

class FXTransactionResponse(FXTransactionBase):
    id: int
    deal_reference: str
    settled_at: Optional[datetime] = None
    created_by_user_id: Optional[str] = None
    created_at: datetime

    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = { decimal.Decimal: str }

class FXTransactionStatusUpdate(BaseModel):
    new_status: str # PENDING_SETTLEMENT, SETTLED, CANCELLED
    settlement_reference: Optional[str] = None # If settled

# --- Treasury Bill Investment Schemas ---
class TreasuryBillInvestmentBase(BaseModel):
    issue_date: date
    maturity_date: date
    tenor_days: int = Field(..., gt=0)
    face_value: decimal.Decimal = Field(..., gt=0, decimal_places=2)
    discount_rate_pa: decimal.Decimal = Field(..., ge=0, le=100, decimal_places=4) # Rate as percentage e.g. 5.75 for 5.75%
    # purchase_price: decimal.Decimal # Can be calculated or provided
    currency: CurrencyEnum = CurrencyEnum.NGN
    status: Optional[str] = "ACTIVE"

    @validator('maturity_date')
    def maturity_must_be_after_issue(cls, v, values):
        if 'issue_date' in values and v <= values['issue_date']:
            raise ValueError('Maturity date must be after issue date.')
        # Further validation for tenor_days vs dates if needed
        return v

class TreasuryBillInvestmentCreateRequest(TreasuryBillInvestmentBase):
    investment_reference: Optional[str] = None # Auto-generated if None
    # If purchase_price is not provided, service should calculate it.
    purchase_price: Optional[decimal.Decimal] = Field(None, gt=0, decimal_places=2)


class TreasuryBillInvestmentResponse(TreasuryBillInvestmentBase):
    id: int
    investment_reference: str
    purchase_price: decimal.Decimal # Now mandatory as it's calculated/set
    matured_at: Optional[datetime] = None
    created_at: datetime

    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = { decimal.Decimal: str }

# --- Interbank Placement Schemas ---
class InterbankPlacementBase(BaseModel):
    placement_type: str # LENDING or BORROWING
    counterparty_bank_code: str
    counterparty_bank_name: str
    principal_amount: decimal.Decimal = Field(..., gt=0, decimal_places=2)
    currency: CurrencyEnum
    interest_rate_pa: decimal.Decimal = Field(..., ge=0, decimal_places=4)
    placement_date: date
    maturity_date: date
    tenor_days: int = Field(..., gt=0)
    status: Optional[str] = "ACTIVE"

class InterbankPlacementCreateRequest(InterbankPlacementBase):
    deal_reference: Optional[str] = None # Auto-generated if None

class InterbankPlacementResponse(InterbankPlacementBase):
    id: int
    deal_reference: str
    # interest_amount_expected: decimal.Decimal
    # total_repayment_expected: decimal.Decimal
    matured_at: Optional[datetime] = None
    created_at: datetime

    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = { decimal.Decimal: str }

# --- CBN Repo Operation Schemas ---
class CBNRepoOperationBase(BaseModel):
    operation_type: str # REPO or REVERSE_REPO
    loan_amount: decimal.Decimal = Field(..., gt=0, decimal_places=2)
    currency: CurrencyEnum = CurrencyEnum.NGN
    interest_rate_pa: decimal.Decimal = Field(..., ge=0, decimal_places=4)
    start_date: date
    end_date: date
    tenor_days: int = Field(..., gt=0)
    status: Optional[str] = "ACTIVE"
    # Collateral details might be complex, simplified here or managed separately
    # collateral_security_type: Optional[str] = None
    # collateral_security_id: Optional[str] = None

class CBNRepoOperationCreateRequest(CBNRepoOperationBase):
    operation_reference: Optional[str] = None # Auto-generated

class CBNRepoOperationResponse(CBNRepoOperationBase):
    id: int
    operation_reference: str
    completed_at: Optional[datetime] = None
    created_at: datetime

    class Config:
        orm_mode = True
        use_enum_values = True
        json_encoders = { decimal.Decimal: str }

# --- Liquidity Forecast/Monitoring Schemas (Conceptual) ---
class LiquidityForecastRequest(BaseModel):
    forecast_date: date
    projection_days: int = Field(7, gt=0, le=90) # e.g. 7-day forecast

class LiquidityGap(BaseModel):
    tenor_bucket: str # e.g., "Overnight", "1W", "1M", "3M"
    inflows: decimal.Decimal
    outflows: decimal.Decimal
    net_gap: decimal.Decimal # inflows - outflows
    cumulative_gap: decimal.Decimal

class LiquidityForecastResponse(BaseModel):
    forecast_as_of_date: date
    gaps: List[LiquidityGap]
    # Other metrics like LCR (Liquidity Coverage Ratio), NSFR (Net Stable Funding Ratio) if calculated
    # lcr_ratio: Optional[decimal.Decimal] = None

    class Config:
        json_encoders = { decimal.Decimal: str }

class PaginatedFXTransactionResponse(BaseModel):
    items: List[FXTransactionResponse]
    total: int
    page: int
    size: int

class PaginatedTreasuryBillInvestmentResponse(BaseModel):
    items: List[TreasuryBillInvestmentResponse]
    total: int
    page: int
    size: int

class PaginatedInterbankPlacementResponse(BaseModel):
    items: List[InterbankPlacementResponse]
    total: int
    page: int
    size: int
