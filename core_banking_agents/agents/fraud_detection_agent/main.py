# FastAPI app for Fraud Detection Agent
from fastapi import FastAPI, HTTPException, status, BackgroundTasks
from typing import Dict, Any, List
import logging
from datetime import datetime
import asyncio # For mock background task sleep

from .schemas import TransactionEventInput, FraudAnalysisOutput, RiskLevel, FraudActionRecommended
# Import agent interaction logic
from .agent import analyze_transaction_for_fraud_async

# --- Logging Setup ---
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# --- In-memory Store ---
MOCK_TRANSACTION_EVENTS_LOG: List[Dict[str, Any]] = [] # Stores basic info about received events
MOCK_FRAUD_ANALYSIS_RESULTS: Dict[str, FraudAnalysisOutput] = {} # event_id -> FraudAnalysisOutput

app = FastAPI(
    title="Fraud Detection Agent API (Agent Integrated - Mocked)",
    description="Monitors real-time transactions for suspicious activity and provides fraud analysis via an AI Agent.",
    version="0.1.1", # Incremented version
    contact={
        "name": "Core Banking AI Security Team",
        "email": "ai-security@examplebank.ng",
    },
)

# --- Background Task Runner ---
async def run_fraud_analysis_background(event_input: TransactionEventInput):
    """
    Wrapper to run the fraud detection agent workflow in the background
    and update the mock results store.
    """
    logger.info(f"Background task started for fraud analysis of event: {event_input.event_id}")
    try:
        # Call the agent's workflow function
        agent_analysis_dict = await analyze_transaction_for_fraud_async(event_input)

        # Validate and store the detailed assessment from the agent
        if event_input.event_id:
            try:
                # Create a FraudAnalysisOutput object from the agent's dictionary result
                # This ensures that the data stored matches the schema.
                # The agent_analysis_dict should already include event_id.
                # analysis_id and analysis_timestamp will be auto-generated by Pydantic model.
                final_analysis_result = FraudAnalysisOutput(**agent_analysis_dict)
                MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id] = final_analysis_result
                logger.info(f"Background task completed for event {event_input.event_id}. Analysis Risk Level: {final_analysis_result.risk_level}, Action: {final_analysis_result.recommended_action}")
            except Exception as e: # Catch Pydantic validation errors or others
                logger.error(f"Error parsing agent analysis for event {event_input.event_id}: {e}. Data: {agent_analysis_dict}", exc_info=True)
                # Update status to reflect error during agent processing or data parsing
                if event_input.event_id in MOCK_FRAUD_ANALYSIS_RESULTS:
                    current_analysis = MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id]
                    current_analysis.status = "FailedToAnalyze"
                    current_analysis.reason_for_action = f"Error processing agent's analysis result: {str(e)}"
                    current_analysis.analysis_timestamp = datetime.utcnow()
                else: # Should not happen if initial pending was stored
                    MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id] = FraudAnalysisOutput(
                        event_id=event_input.event_id, status="FailedToAnalyze",
                        reason_for_action=f"Error processing agent's analysis result: {str(e)}"
                    )
        else:
            logger.error(f"Event ID missing in agent analysis result for transaction {event_input.transaction_id}")

    except Exception as e:
        logger.error(f"Critical error in fraud analysis background task for event {event_input.event_id}: {e}", exc_info=True)
        if event_input.event_id in MOCK_FRAUD_ANALYSIS_RESULTS:
            analysis_entry = MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id]
            analysis_entry.status = "FailedToAnalyze"
            analysis_entry.reason_for_action = f"Agent workflow failed critically: {str(e)}"
            analysis_entry.analysis_timestamp = datetime.utcnow()
        # else create a new error entry (though initial pending should exist)


@app.get("/", tags=["General"])
async def root():
    """Root endpoint for the Fraud Detection Agent."""
    logger.info("Fraud Detection Agent root endpoint accessed.")
    return {"message": "Fraud Detection Agent is running. Agent integration active (mocked). See /docs."}

@app.post("/events/transaction", response_model=FraudAnalysisOutput, status_code=status.HTTP_202_ACCEPTED, tags=["Fraud Analysis"])
async def submit_transaction_event(
    event_input: TransactionEventInput,
    background_tasks: BackgroundTasks
):
    """
    Submits a financial transaction event for fraud analysis.
    The AI Fraud Detection Agent performs analysis asynchronously.
    This endpoint acknowledges receipt and returns an initial 'PendingAnalysis' status.
    """
    logger.info(f"API: Received transaction event for analysis: ID {event_input.event_id}, Type {event_input.transaction_type}, Amount {event_input.amount} {event_input.currency}")

    if event_input.event_id in MOCK_FRAUD_ANALYSIS_RESULTS and MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id].status == "Completed":
        logger.warning(f"Transaction event with ID {event_input.event_id} has already been analyzed. Returning existing result.")
        return MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id]
        # Or raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=f"Event ID {event_input.event_id} already processed.")


    # Log basic event info
    MOCK_TRANSACTION_EVENTS_LOG.append({
        "event_id": event_input.event_id, "transaction_id": event_input.transaction_id,
        "timestamp": event_input.timestamp.isoformat(), "status": "ReceivedForAnalysis"
    })
    if len(MOCK_TRANSACTION_EVENTS_LOG) > 1000: MOCK_TRANSACTION_EVENTS_LOG.pop(0)

    initial_analysis = FraudAnalysisOutput(
        event_id=event_input.event_id,
        status="PendingAnalysis",
        reason_for_action="Transaction event received and queued for fraud analysis by AI agent."
    )
    MOCK_FRAUD_ANALYSIS_RESULTS[event_input.event_id] = initial_analysis

    background_tasks.add_task(run_fraud_analysis_background, event_input)
    logger.info(f"API: Transaction event {event_input.event_id} accepted. Fraud analysis agent workflow scheduled.")

    return initial_analysis

@app.get("/analysis/{event_id}", response_model=FraudAnalysisOutput, tags=["Fraud Analysis"])
async def get_fraud_analysis_result(event_id: str):
    """
    Retrieves the fraud analysis result for a given event ID.
    Poll this endpoint for updates after submitting a transaction event.
    """
    logger.info(f"API: Fetching fraud analysis result for event ID: {event_id}")

    analysis_result = MOCK_FRAUD_ANALYSIS_RESULTS.get(event_id)
    if not analysis_result:
        logger.warning(f"Fraud analysis for event ID {event_id} not found.")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"Fraud analysis for event ID {event_id} not found.")

    logger.info(f"API: Returning analysis for event {event_id}. Status: {analysis_result.status}, Risk: {analysis_result.risk_level}")
    return analysis_result

# --- Main block for Uvicorn ---
if __name__ == "__main__":
    logger.info("Fraud Detection Agent FastAPI application (Agent Integrated - Mocked). To run, use Uvicorn from project root:")
    logger.info("`uvicorn core_banking_agents.agents.fraud_detection_agent.main:app --reload --port 8004`")
    pass
